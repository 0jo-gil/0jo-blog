{"componentChunkName":"component---src-templates-post-template-tsx","path":"/posts/typescript-utility-types/","result":{"data":{"markdownRemark":{"rawMarkdownBody":"## 유틸리티 타입 (Utility Types)\nTypeScript를 사용하면서 실제 타입만 정의하고 확장성있는 타입 자체를 응용하는 과정에서 타입 정의를 위한 또 다른 타입을 정의하는 상황에 직면하곤 했다.\n\n이러한 상황을 해결하기 위해 _**[유틸리티 타입](https://www.typescriptlang.org/ko/docs/handbook/utility-types.html)**_ 을 타입스크립트에서 제공한다.\n\n> TypeScript는 일반적인 타입 변환을 쉽게 하기 위해 유틸리티 타입을 제공한다. 이러한 유틸리티는 전역으로 사용 가능하다.\n\n\n---\n\n### Partial&lt;T&gt;\nType의 모든 프로퍼티를 선택적으로 변경한 타입 생성\n\n\n```\ninterface User {\n\tname: string;\n    age: number;\n}\n\nfunction updateUser(user: User, updateUser: Partial<User>) {\n\treturn { ...user, ...updateUser};\n}\n\nconst userA = {\n\tname: 'name',\n    age: 32\n};\n\nconst userB = updateUser(userA, {\n\tage: 30\n});\n```\n\n### Required&lt;T&gt;\nType의 모든 프로퍼티를 필수로 설정한 타입 생성\n\n```\ninterface User {\n\tname?: string;\n    age?: number;\n}\n\nconst userA: User = { name: 'name' };\nconst userB: Required<User> = {\n\tname: 'name',\n    age: 30\n}\n```\n\n### Readonly&lt;T&gt;\nType의 모든 프로퍼티가 읽기 전용 (readonly)으로 설정한 타입 생성\n생성된 타입의 프로퍼티는 재할당 불가\n```\ninterface User {\n\tname: string;\n}\n\nconst userA: Readonly<User> = { name: 'name' };\nuserA.name = 'name2'; // error\n```\n\n### Record&lt;Keys, Type&gt;\n키를 속성으로, 타입을 속성값의 타입으로 설정한 타입 생성\n타입의 프로퍼티를 다른 타입에 매핑시키는데 사용\n```\ntype Key = 'name' | 'age';\n\ntype Record = Record<Key, string>;\n\n/*\ntype Record = {\n\tname: string;\n    age: string;\n}\n*/\n\nconst userA: Record<Key, string> = {\n\tname: 'name',\n    age: '10'\n}\n```\n\n### Pick&lt;Type, Keys&gt;\nType의 프로퍼티에서 Key의 집합 타입 생성\n```\ninterface User {\n\tname: string;\n    age: number;\n    phone: string;\n}\ntype Key = 'name' | 'phone';\ntype UserPick = Pick<User, Key>;\n/*\ntype UserPick = {\n\tname: string;\n    phone: string;\n}\n*/\n\nconst user: Pick<User, Key> = {\n\tname: 'name',\n    phone: '010-0000-0000'\n}\n```\n\n### Omit&lt;Type, Keys&gt;\nPick 과 반대로 Type의 해당 Key의 집합을 제외한 타입 생성\n```\ninterface User {\n\tname: string;\n    age: number;\n    phone: string;\n}\n\ntype Key = 'age' | 'phone';\n\ntype UserOmit = Omit<User, Key>;\n/*\ntype UserOmit = {\n\tname: string;\n}\n*/\n\nconst user: Omit<User, Key> = {\n\tname: 'name'\n}\n```\n\n### Exclude&lt;Type, ExcludedUnion&gt;\n\n```\n// type Type1 = 'b' | 'c'\ntype Type1 = Exclude<'a' | 'b' | 'c', 'a'>;\n\n// type Type2 = 'c'\ntype Type2 = Exclude<'a' | 'b' | 'c', 'a', 'b'>;\n\n// type Type3 = string | number\ntype Type3 = Exclude<string | number | (() => void), Function>;\n```\n\n### Extract&lt;Type, Union&gt;\nUnion에 할당할 수 있는 모든 멤버를 추출\n\n```\ntype Type1 = string | number | object;\ntype Type2 = number | object;\n\ntype ExtractType = Extract<Type1, Type2>;\n/*\ntype ExtractType = number | object;\n*/\n\nconst reault: Extract<Type1, Type2> = 1;\n```\n\n### NonNullable&lt;Type&gt;\nType에서 null과 undefined 제외한 타입 생성\n\n```\n// Type1 = string | number;\ntype Type1 = NonNullable<string | number | undefined>;\n// Type2 = string;\ntype Type2 = NonNullable<string | null>;\n\n```\n\n### Parameters&lt;Type&gt;\n함수 타입 Type의 매개변수에 사용된 타입에서 튜플 타입 생성\n\n```\nfunction example(a: number, b: string): void {\n\t...\n}\n\n// type ExampleParams = [number, string]\ntype ExampleParams = Parameters<typeof example>;\n\n```\n\n### ConstructorParameters&lt;Type&gt;\n생성자 함수의 매개변수 타입에서 튜플 타입 생성\n```\nclass User {\n\t...\n    constructor(name: string, age: number) {\n    \t...\n    }\n    ...\n}\n\nconst user = new User('name', 30);\n\n// UserType = [string, number]\ntype UserType = ConstructorParameters<typeof User>\n```\n\n\n### ReturnType&lt;Type&gt;\n함수 Type의 반환 타입으로 구성된 타입 생성\n```\nfunction example(a: number): number {\n\treturn a;\n}\n\n// Type = number;\ntype Type = ReturnType<typeof example>;\n```\n\n### InstanceType&lt;Type&gt;\n생성자 함수의 인스턴스 타입으로 구성된 타입 생성\n\n```\nclass User {\n\t...\n    constructor(name: string, age: number) {\n    \t...\n    }\n    ...\n}\n\n// InstanceTypeUser = { name: string, age: number }\ntype InstanceTypeUser = InstanceType<typeof User>;\n\nconst user: InstanceTypeUser<typeof User> = {\n\tname: 'name',\n    age: 30\n}\n```\n\n### ThisParameterType&lt;Type&gt;\n함수의 this 매개변수 타입 생성\n함수 타입에 this 매개변수가 없을 경우 unknown 추출\n\n```\ninterface User {\n\tname: string;\n}\n\nconst user: User = {\n\tname: 'name'\n}\n\nfunction getUser(this: User): string {\n\treturn this.name\n}\n\n// Type = User;\ntype Type = ThisParameterType<typeof getUser>;\n```\n\n### OmitThisParameter&lt;Type&gt;\nType에서 this를 제거한 타입 생성\n\n```\ninterface User {\n\tname: string;\n}\n\nfunction getUser(this: User): string {\n\treturn this.name;\n}\n\nconst user = {\n\tname: 'name'\n}\n\n\ngetUser.call(user); // 'name'\n\nconst userB = {\n\tname: false\n}\n\ngetUser.call(userB); // Error ! 실제 정의한 타입 (string)과 일치하지 않기 때문에 타입 에러 발생\n```\n\n```\n// this 매개변수 제거 타입 생성\n// Type = (this: any) => string  !! 명시적 this 매개변수 타입을 제거했기 때문에 any타입\ntype Type = OmitThisParameter<typeof getUser>;\n\nconst getUserByRandom = OmitThisParameter<typeof getUser> = getUser;\n\ngetUserByRandom.call(userB); // false\n```","frontmatter":{"title":"유틸리티 타입 (Utility Types)","date":"2023-12-27","category":["TypeScript"],"slug":"typescript-utility-types"}}},"pageContext":{"slug":"typescript-utility-types"}},"staticQueryHashes":[],"slicesMap":{}}